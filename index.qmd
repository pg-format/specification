---
title: Property Graph Exchange Format (PG)
---

*THIS IS WORK IN PROGRESS. See also <https://github.com/orgs/pg-format/discussions> and <https://github.com/pg-format/pg-formatter/wiki> for discussion and references!*

## Introduction

### Why property graphs?

**Property Graphs** (also known as **Labeled Property Graphs**) are used as
abstract data structure in graph databases and related applications. 

Implementations of property graphs slightly differ in support of data types,
restrictions on labels etc. The [definition of property graphs](#data-model)
used in this specification is aimed to be a superset of property graph models
of common graph databases and formats. The model and its serializations have
first been proposed by Hirokazu Chiba, Ryota Yamanaka, and Shota Matsumoto
([2019](https://arxiv.org/abs/1907.03936),
[2022](https://arxiv.org/abs/2203.06393)) and revised into this specification
together with Jakob Voß.

### About this document

The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to
be interpreted as described in BCP 14 ([RFC 2119] and [RFC 8174]) when, and
only when, they appear in all capitals, as shown here.

Normative parts of this specification are limited to section [2](#data-model)
to [6](#rubustness-priniciple) and [the normative
references](#normative-references).

## Data Model

A **property graph** consists of **nodes** and **edges** between these nodes.
Each node has a unique **node identifier**. Each edge is either directed or
undirected and can have an optional **edge identifier**. Each of the nodes and
edges can have **properties** and **labels**. Properties are mappings from
**keys** to non-empty lists of **values**. Node identifiers, labels, and keys
are non-empty Unicode strings. A value is a Unicode string, a boolean value, or
a number as defined by [RFC 8259].

Extended graph features not being part of this data model include *graph
attributes*, *hierarchies*, *hyper-edges* and *semantics* of individual labels
and property keys.

## PG format

A **PG format** document allows writing down a property graph in a compact textual
form. A PG format document is a Unicode string that conforms to [grammar] and rules
defined in this specification.

### Basic structure

A PG format document encodes a property graph as Unicode string. The document
MUST be encoded in UTF-8 (RFC 3629). Unicode codepoints can also be given by
escape sequences in [quoted strings](#quoted-strings).

The document consists of a sequence of **statements**, each defining
a [node](#nodes) or an [edge](#edges), being empty (consisting of
[whitespace](#whitespace) only). Statements are separated from each other with
a [line break](#whitespace). Optional [spaces](#whitespace) and/or
a [comment](#whitespace) at the end of a statement are ignored.

### Identifiers

[identifier]: #identifiers

An **identifier** is a string used to uniquely identify a [node](#nodes), an
[edge](#edges), a [label](#labels), or the name of a [property](#properties).
An identifiers can be given as [quoted string](#quoted-strings) or as unquoted
identifier.

An **unquoted identifier** is a non-empty string not including control codes
(`U+0000` to `U+0020`, this includes line breaks and space), nor any of the
characters "`<`" (`U+003C`), "`>`" (`U+003E`), '`"`' (`U+0022`), "`{`"
(`U+007B`), "`}`" (`U+007D`), "`|`" (`U+007C`), "`\`" (`U+005C`), "`^`"
(`U+005E`), and "`` ` ``" (`U+0060`).^[This definition is equivalent to the
definition of IRI references [in
Turtle](https://www.w3.org/TR/turtle/#grammar-production-IRIREF) and [in
SPARQL](https://www.w3.org/TR/sparql11-query/#rIRIREF) with the exclusion of
empty strings.]

~~~{.pg #lst-identifiers lst-cap="Several unquoted identifiers"}
abc
~2
木
dc:title
http://example.org/?a=-&c=0
~~~

An unquoted identifier MUST NOT start with a colon (`U+003A`).

~~~{.pg .invalid #lst-invalid-id lst-cap="Invalid unquoted identifier"}
:id
~~~

An unquoted identifier cannot start with hash ("`#`") because this starts
a [comment](#whitespace) nor with apostrophe ("`'`") or quotation mark ("`"`")
because these start a [quoted string](#quoted-strings). Colon, hash, and
apostrophe can be used in unquoted identifiers if not as first character.

### Nodes

A **node** consists of the following elements, given in this order and
separated by [delimiting whitespace](#whitespace):

- A REQUIRED [identifier](#identifiers)
- an OPTIONAL list of [labels]
- an OPTIONAL list of [properties]

~~~{.pg #lst-nodes lst-cap="Some node statements"}
id :label key:value
42 :answer
"node id with spaces"
~~~

#### Node merging

A node can be defined with multiple statements having the same node identifier:
a node is **merged** with an existing node by appending labels and property
values.

~~~{.pg #lst-node-merging-1 lst-cap="One node defined by multiple statements"}
a :x k:1 m:true
a :y k:2
~~~

~~~{.pg #lst-node-merging-2 lst-cap="Same node defined by one statement"}
a :x :y k:1,2 m:true
~~~

#### Implicit nodes

Nodes can also be defined implicitly as part of an [edge](#edges): node
identifiers referenced in edges imply the existence of nodes with these
identifiers.

~~~{.pg #lst-implicit-nodes lst-cap="Simple graph with two nodes and one edge"}
a -> b
~~~

~~~{.pg #lst-explicit-nodes lst-cap="Same graph with explicit node statements"}
a
b
a -> b
~~~

### Edges

A **edge** consists of the following elements, given in this order and separated by [delimiting whitespace](#whitespace):

- an OPTIONAL **[edge identifier](#edge-identifiers)**
- a REQUIRED source node [identifier]
- a REQUIRED **[direction](#edge-directions)**
- a REQUIRED target node [identifier]
- an OPTIONAL list of [labels]
- an OPTIONAL list of [properties]

~~~{.pg #lst-edges lst-cap="Some edge statements"}
1: a -> b :label key:value
a -- b
~~~

The following statement does not define an edge but a [node](#nodes) with identifier "`a--b`":

~~~{.pg #lst-no-edge-but-node lst-cap="Not an edge statement"}
a--b
~~~

The following is not valid:

~~~{.pg .invalid #lst-invalid-edge lst-cap="Invalid edge statement"}
a->b
~~~

#### Edge identifiers

An edge identifier is an [identifier] as first element of an edge statement,
directly followed by a colon (`U+003A`).

~~~{.pg #lst-multi-edges-with-id lst-cap="Graph with two equivalent edges, differentiated by edge identifiers"}
1: a -> b :follows since:2024
"x": a -> b :follows since:2024
~~~

Colons are not forbidden in edge identifiers:

~~~{.pg #lst-colon-in-edge-id lst-cap="Edge identifiers with colon"}
x:: a -> b  # edge identifier "x:"
":" a -> b  # edge identifier ":"
~~~

Edge identifiers MUST NOT be repeated.

~~~{.pg .invalid #lst-invalid-edge-ids lst-cap="The second statement is invalid because of repeated edge identifier"}
1: a -> b :follows
1: a -> b since:2024
~~~

No space is allowed between edge identifier and its colon:

~~~{.pg .invalid #lst-invalid-edge-id lst-cap="Invalid statement"}
1 : a -> b
~~~

#### Edge directions

The direction element of an edge is either the character sequence `->` for
a directed edge or the character sequence `--` for an undirected edge.

#### Loops

Edges can connect a node to itself.

~~~{.pg #lst-lops lst-cap="Directed and undirected loop"}
a -> a
a -- a
~~~

#### Multi-edges

The Property Graph Data Model allows for multiple edges between same nodes.

~~~{.pg #lst-multi-edges lst-cap="Graph with two indistinguishable edges"}
a -> b :follows since:2024
a -> b :follows since:2024
~~~

[Edge identifiers](#edge-identifiers) can be used to identify and reference
individual multi-edges.

### Labels

A label is a an [identifier] following a colon (`U+003A`) and optional
[spaces](#whitespace).

Labels of a node or an edge are unique: repeated labels are ignored.
Applications SHOULD preserve the order of labels of a node or an edge.

~~~{.pg #lst-labels lst-cap="Repeated labels on same node or edge are ignored"}
a :label1 :label2 :label1   # label1 is repeated
a :label1 :label2           # equivalent statement
a : label1 : label2         # equivalent statement
~~~

Colons are not forbidden in labels:

~~~{.pg #lst-colon-in-labels lst-cap="Labels with colons"}
a :b:c                      # label "b:c"
a :http://example.org/      # label "http://example.org/"
~~~

### Properties


*This section has not been finished yet*

...

- values don't have data types other than string, boolean, and number
- as specified in [RFC 8259], implementations MAY set limits on the range and
  precision of numbers and double precision (IEEE754) is the most likely common limit
- values of the same property key are allowed to have different types
- a property must have at least one value

### Quoted Strings

A quoted string starts with an apostrophe ("`'`") or quotation mark ("`"`") and
ends with the same character. In between all Unicode characters are allowed,
except for the characters that MUST be escaped:

- apostrophe, when the string is quoted with apostrophe
- quotation mark, when the string is quoted with quotation mark
- reverse solidus (`\` `U+005C`)
- control characters `U+0000` through `U+001F` except line feed
  (`U+000A`), carriage return (`U+000D`), and tabular (`U+0009`)

All characters can be escaped as defined by JSON specification ([RFC 8259],
section 7) with the addition of the two-character escape sequence `\'` to
escape an apostrophe. Quoted strings in PG format further differ from JSON by
string quoting with apostrophe in addition to quotation mark and by allowing
unquoted line feed, carriage return, and tabular. 

~~~{.pg #lst-strings lst-cap="The same string given in multiple quoted forms"}
"hello,\nworld"
"hello,\u000Aworld"
"hello,
world"
~~~

### Whitespace

A **line break** is either a line feed (`U+000A`) or a carriage return
(`U+000D`) optionally followed by a line feed.

**Spaces** are a non-empty sequence of space (`U+0020`) and/or tabular (`U+0009`).

A **comment** begins with a hash (`#` = `U+0023`) and it ends before the next
[line break](#whitespace) or at the end of the document.

**Delimiting whitespace** separates elements of a statement. Delimiting
whitespace consists of an optional sequence of [spaces](#whitespace),
[comment](#whitespace), and/or [line breaks](#whitespace) and it ends with
[spaces](#whitespace). The inclusion of line breaks in delimiting whitespace is
also called *line folding*.

~~~{.pg #lst-line-folding lst-cap="Line folding"}
a :x  # node id and label
  # this and the following line are empty 

  :y  # another label of the same node at continuation line
~~~

~~~{.pg #lst-line-folding lst-cap="Same graph as above"}
a :x :y
~~~

### Grammar

*A formal grammar of PG format will be provided*


## PG-JSON

A **PG-JSON** document serializes a property graph in JSON. A PG-JSON document
is a JSON document ([RFC 8259]) with a JSON object with exactely two fields:

- `nodes` an array of nodes
- `edges` an array of edges

Each node is a JSON object with exactely three fields:

- `id` the node identifier, being a non-empty string.
  Node identifiers MUST be unique per PG-JSON document.
- `labels` an array of labels, each being a non-empty string.
  Labels MUST be unique per node.
- `properties` a JSON object mapping non-empty strings as property keys to
  non-empty arrays of scalar JSON values (string, number, boolean) as property values.

Each edge is a JSON object with one optional and four mandatory fields:

- `id` (optional) the edge identifier, being a non-empty string.
  Edge identifiers MUST be unique per PG-JSON document.
- `undirected` (optional) a boolean value whether the edge is undirected
- `from` an identifier of the source node from `nodes` array
- `to` an identifier of the target node from `nodes` array
- `labels` and `properties` as defined above at nodes

## PG-JSONL

A **PG-JSONL** document or stream serializes a property graph in JSON Lines
format, also known as newline-delimited JSON. A PG-JSONL document is a sequence
of JSON objects, separated by line separator (`U+000A`) and optional whitespace
(`U+0020`, `U+0009`, and `U+000D`) around JSON objects, and an optional line
separator at the end. Each object is

- either a node with field `type` having string value `"node"` and the same
  mandatory node fields from PG-JSON format,
- or an edge with field `type` having string value `"edge"` and the same
  mandatory edge fields from PG-JSON format.

Node objects SHOULD be given before their node identifiers are referenced in an
edge object but applications MAY also create implicit node objects for this
cases. Applications MAY allow multiple node objects with same node identifier
in PG-JSONL but they MUST make clear whether nodes with repeated identifier are
ignored, merged into existing nodes, or replace existing nodes.

## Robustness principle

Applications MAY automatically convert documents not fully conforming to the
specification of PG-JSON and/or PG-JSONL to valid form, for instance by:

- creation of implicit nodes for node identifiers referenced in edges
- addition of missing empty fields `labels` and/or `properties`
- removal or mapping of invalid property values such as `null` and JSON objects
- mapping of numeric node identifiers and edge identifiers to strings
- removal of additional fields not defined in this specification

## JSON Schemas

The [PG-JSON format](#pg-json) can be validated with a non-normative JSON Schema file [`pg-json.json`](schema/pg-json.json) in this repository. Rules not covered by the JSON schema include:

- nodes referenced in edges must be defined (no implicit nodes)
- node identifiers must be unique per graph
- edge identifiers must be unique per graph

The [PG-JSONL format](#pg-jsonl) can be validated with a non-normative JSON Schema file [`pg-jsonl.json`](schema/pg-jsonl.json) in this repository. Validation is limited in the same way as validation of PG-JSON with its JSON Schema.

## References

### Normative References

[RFC 2119]: https://tools.ietf.org/html/rfc2119
[RFC 3629]: https://tools.ietf.org/html/rfc3629
[RFC 8174]: https://tools.ietf.org/html/rfc8174
[RFC 8259]: https://tools.ietf.org/html/rfc8259

- Bradner, S.: Key words for use in RFCs to Indicate Requirement Levels.
  BCP 14, RFC 2119, March 1997,
  <http://www.rfc-editor.org/info/rfc2119>.
              
- Bray, T.: The JavaScript Object Notation (JSON) Data Interchange Format.
  RFC 8259, December 2017. <https://tools.ietf.org/html/rfc8259>

- Leiba, B.:  Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words.
  BCP 14, RFC 8174, May 2017,
  <http://www.rfc-editor.org/info/rfc8174>.
  
- The Unicode Consortium: The Unicode Standard.
  <http://www.unicode.org/versions/latest/>

- Yergeau, F.: UTF-8, a transformation format of ISO 10646.
  RFC 3629, November 2003. <https://tools.ietf.org/html/rfc3629>

### Informative references

- [JSON Schema](https://json-schema.org/) schema language

- [IEEE Standard for Floating-Point Arithmetic](https://doi.org/10.1109/IEEESTD.2019.8766229)

